# Producer-Consumer Problem with Shared Memory and Synchronization

This project demonstrates a solution to the producer-consumer problem using shared memory, semaphores, and a mutex. Two processes, `producer` and `consumer`, are created to manage items in a shared buffer with a limited size (`N`). The producer adds items to the buffer, while the consumer removes them, with both processes synchronized to avoid race conditions and buffer overflows.

## Files

- **main.c**: Contains the `producer` and `consumer` functions and manages the flow of the program. The producer generates random items and adds them to a shared buffer, while the consumer removes items from the buffer. Both functions utilize semaphores and a mutex to manage access to shared resources.
- **shared.c**: Contains functions for setting up and cleaning up shared memory and synchronization mechanisms (semaphores and mutex). It also provides utility functions such as `print_buffer` to display the buffer state.
- **shared.h**: Defines constants, shared variables, and function prototypes for managing shared resources and synchronization.

## Code Overview

### main.c

1. **Producer Function**:
   - Generates random integers and attempts to add them to the buffer.
   - If the buffer is full, it waits for a slot to be freed.
   - Acquires the `mutex` to ensure exclusive access to the buffer, adds the item, and increments the count of items in the buffer.
   - Releases the `mutex` and signals the `full` semaphore after adding an item.
   - Waits for a short period between items.

2. **Consumer Function**:
   - Waits for an item to become available in the buffer.
   - Acquires the `mutex` to access the buffer, removes the oldest item, shifts remaining items, and decrements the count.
   - Releases the `mutex` and signals the `empty` semaphore after removing an item.
   - Waits for a short period before attempting to consume another item.

3. **Main Function**:
   - Calls `setup_shared_memory` to initialize shared memory and semaphores.
   - Forks a child process, with the parent process running `producer` and the child process running `consumer`.
   - Waits for the child process to complete and calls `cleanup_shared_memory` to release resources.

### shared.c

1. **setup_shared_memory**:
   - Allocates shared memory for the buffer, count, and mutex.
   - Initializes semaphores for managing the buffer state (`empty` and `full`).
   - Sets the mutex for controlling buffer access.
   - Initializes the buffer to empty state and count to zero.

2. **print_buffer**:
   - Outputs the current state of the buffer, showing slots that are occupied and empty, for debugging and tracking.

3. **cleanup_shared_memory**:
   - Closes and unlinks the semaphores and shared memory objects, and destroys the mutex.

### shared.h

Defines constants for the buffer size (`N`) and shared memory object names, as well as declarations for shared variables and functions used across the program.

## Output Example

Here is an example of the output generated by running the program:

Producer : Buffer => [ 83 _ _ _ ]

Consumer : Buffer => [ _ _ _ _ ]

Producer : Buffer => [ 86 _ _ _ ]

Producer : Buffer => [ 86 77 _ _ ] ...


The output shows the buffer's state after each operation, indicating how the producer and consumer processes interact and manage the buffer.

## Setup and Compilation

To compile and run this program:

```bash
gcc main.c shared.c -o producer_consumer -lpthread -lrt
./producer_consumer
